\documentclass[11pt]{article}

\usepackage{tikz-cd}
\usepackage{proof-dashed}
\input{macros}

\newcommand{\U}{\mathbb{U}}
\renewcommand{\SS}{\mathbb{S}}
\newcommand{\lolli}{\multimap}
\newcommand*{\Void}{\mathsf{0}}
\newcommand*{\Unit}{\mathsf{1}}
\newcommand*{\Bool}{\mathsf{2}}

\newcommand*{\Interval}{I}
\newcommand*{\Izero}{0_I}
\newcommand*{\Ione}{1_I}
\newcommand*{\Iseg}{\mathsf{seg}}

\newcommand*{\ap}{\mathsf{ap}}
\newcommand*{\apd}{\mathsf{apd}}

\newcommand*{\funext}{\mathsf{funext}}
\newcommand*{\isSet}{\mathsf{isSet}}
\newcommand*{\isProp}{\mathsf{isProp}}
\newcommand*{\elimtrunc}{\mathsf{elim}}
\newcommand*{\isContr}{\mathsf{isContr}}
\newcommand*{\squash}{\mathsf{squash}}
\newcommand{\iseq}{\mathsf{isequiv}}
\newcommand{\qinv}{\mathsf{qinv}}
\newcommand*{\comp}{\mathbin{\circ}}

\newcommand{\biequiv}{\mathsf{biequiv}}
\newcommand{\isContrf}{\mathsf{isContr}}
\newcommand{\ishae}{\mathsf{ishae}}
\newcommand{\fib}{\mathsf{fib}}

\newcommand{\merid}{\mathsf{merid}}

\newcommand*{\isNtype}[1]{\mathsf{is}\mbox{-}#1\mbox{-}\mathsf{type}}
\newcommand{\susp}[1]{\mathsf{Susp}(#1)}

\newtheorem{lemma}{Lemma}
\newtheorem{thm}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{defn}{Definition}

\title{15-819 Homotopy Type Theory\\Lecture Notes}
\author{Matthew Maurer and Stefan Muller}
\begin{document}
\maketitle
\section{Contents}
\section{Recap}
%% Clean up and add more text - Stefan
Construction of the suspension of a type. We are using different notation from the book, namely $\susp{A}$ as opposed to $\sum A$.
Specifically, we recall that we can construct the meridian, e.g. if we have
$$N : \susp{A}$$
$$S : \susp{A}$$
$$merid : \Pi x : A . N =_{\susp{A}} S$$
$$x : \susp{A} \vdash B(X) : \U$$
$$n : B(N)$$
$$s : B(S)$$
$$x : A \vdash m : n =_{merid(x)}^{z.B} s$$
% Missed the end of this while getting latex document setup
\section{Equivalence of $\susp{2}$ and $\SS^1$}
%TODO Cleanup: Maurer
%"Fact"
\begin{proposition}
$$\susp{2} \simeq \SS^1$$
\end{proposition}
\begin{proof}
$$f : \susp{2} \rightarrow \SS^1$$
defined by 
$$N \mapsto base$$
$$S \mapsto base$$
these merid terms are in some kind of ap shorthand %% TODO: Explain this
$$merid(tt) \mapsto loop$$
$$merid(ff) \mapsto \refl(base)$$
quasinverse
$$g : \susp{2} \rightarrow \SS^1$$
where we send base is arbitrary but must be consistent
$$base \mapsto N$$
$$loop \mapsto merid(tt) \cdot merid(ff)^{-1}$$
Now need to prove these are inverses
$$\alpha : \Pi x : \susp{2} . g(f(x)) = x$$
By induction
$$(x = N); \refl(N) : N = N$$
$$(x = S); merid(ff) : N = S$$
$$merid(y); ? : \refl(N) =_{merid(y)}^{z.f(g(z) = z} merid(ff)$$
Can case out on this
$$\ap_g (\ap_f (merid(tt))^{-1} \cdot \refl(N) \cdot merid(tt)) = merid(ff)$$
$$\ap_g (\ap_f (merid(ff))^{-1} \cdot \refl(N) \cdot merid(ff)) = merid(ff)$$
stepping evaluation,
$$\ap_g (loop)^{-1} \cdot merid(tt) = merid(ff)$$
$$(merid(tt) \cdot merid(ff)^{-1})^{-1} \cdot merid(ff) = merid(ff)^{-1-1} \cdot merid(tt)^{-1} \cdot merid(tt) = merid(ff)$$

Our other proof of inversion
$$\beta : \Pi x : \SS^1 . f(g(x)) = x$$
by induction on $\SS^1$
$$x = base; \refl(base) : f(g(base)) = base$$
$$x = loop; \ap_f(\ap_g(loop))^{-1} \cdot \refl(base) = \refl base $$
\end{proof}
\section{Pointed Type}
% TODO Maurer
A pointed type is one with an example inhabitant. Notation will be e.g. if A is a pointed type, then we have $a_0 : A$.

e.g. $\Omega(A, a_0) = (a_0 =_A a_0)$ ``the loop space''
The loop space is pointed by $\refl(a_0)$

$\susp{A}$ is pointed by $N$

``strict'' maps = pointed maps = maps in the category of pointed spaces
%That last term I have no idea

$$X \lolli Y := \Sigma f : X \to Y . f(x_0) = y_0$$
\begin{proposition}
$$\susp{A} \lolli B \simeq (A \lolli \Omega B)$$
\end{proposition}
\begin{proof}
Given $f : \susp{A} \lolli B$, define $g : A \lolli \Omega B$ as
$$g a = p_0^{-1} \cdot \ap_f(merid(a) \cdot merid(a_0)^{-1}) \cdot p_0$$
where $f_0$ is the raw map, and $p_0$ is a proof of base point preservation, e.g. $p_0 : f_0(N) = b_0$, and $f = \langle f_0, p_0\rangle$
$$q = \refl(b_0)$$

On the other side, given $g : A \lolli \Omega B$, define $f : \susp{A} \lolli B$

$$f_0(N) = b_0$$
$$f_0(S) = b_0$$
?????
$$\ap_f(merid(a)) = g_0(a)$$
"there is a big diagram to make this work out"

where $g_0$ is the raw map, and $q_0$ is a proof of base point preservation, e.g. $q_0 : g_0(N) = b_0$ and $f = \langle g_0, q_0\rangle$
\end{proof}

\section{Pushouts}
%TODO Stefan
Temporarily, we move back to regular set math.

A pushout is dual of a pullback.

A pullback is an equationally constrained subset of a product.

\begin{equation*}
\begin{tikzcd}
C \arrow{r}{g} \arrow{d}{f} & B \arrow[dashed]{d}{f'} \arrow[bend left]{ddr}{f''}\\
A \arrow[dashed]{r}{g'} \arrow[bend right]{drr}{g''} & A \sqcup^C B \arrow[dashed]{dr}{!}\\
{} & {} & D\\
\end{tikzcd}
\end{equation*}
where f' and g' are identified by f and g

Basically, a pushout is a disjoint union of two types with some of the elements merged together.

$$A \sqcup^C B = (A + B) / R$$
where $R$ is the least equivalence relation containing $\forall c \in C. R(inl(f(c)), inr(g(c)))$

back to hottland

\subsection{Pushouts of $A \xleftarrow{f} C \xrightarrow{g} B$}
\newcommand{\glue}{\mathsf{glue}}

$$\inl : A \rightarrow A \sqcup^C B$$
$$\inr : B \rightarrow A \sqcup^C B$$
$$\glue : \Pi c : C. \Id{A \sqcup^C B} (\inl(f(c)), \inr(g(c)))$$

\[
\infer{z : A \sqcup^C B \vdash rec[D](x.l; y.r; u.q)(z) : D}
{x : A \vdash l : D &
y : B \vdash r : D &
u : C \vdash q : [f(u)/x]l = [g(u)/x]r}
\]

hopefully having the property
$$rec( )(\inl(a)) \equiv [a/x]l$$
$$rec( )(\inr(b)) \equiv [b/y]r$$
$$rec( )(glue(c)) \equiv [c/u]q$$

This construction gives
$$\susp A = 1 \sqcup^A 1$$

Corrallary: The pushout of two sets nedn't be a set (e.g. $\SS^1 = \susp{2}$, but $\SS^1$ is known not to be a set)

\begin{equation*}
\begin{tikzcd}
{} & A \arrow{dr}{!} \arrow{dl}{!} & {}\\
1 \arrow{dr}{\inl} & {} & 1 \arrow{dl}{\inr} \\
{} & \susp{A} & {}\\
\end{tikzcd}
\end{equation*}

\section{Quotients as HITs}
%TODO: Stefan
\newcommand{\trunc}{\mathsf{trunc}}
We can also define quotients of sets by props uing HITs

we examine A/R

Desired properties
Normal ones
We can project an element of $A$ into $A/R$, e.g. by computing its representative
$$q : A \to A/R$$
If we have two elements of $A$ who are related by $R$, then we can construct a proof of equality
$$\mathsf{wd}: \Pi a,b: A. R(a,b) \to q(a) = q(b)$$
A/R is a set, e.g. forced to be truncated to a set
$$\trunc : \Pi x,y: A/R. \Pi p, q : x =_{A/R} y. p = q$$
Saying there is a function from $A/R$ to some type $B$ is the same as saying there is a function from A to B that maps all elements in $R$ to the same element.
$$(A/R) \rightarrow B \simeq \sum_{f : A \rightarrow B} . \Pi_{a, b : A} . R(a, b) \rightarrow f(a) =_B f(b)$$

Example.
%% TODO: Expand
$$Z = (N \times N) / R$$
for suitable R, e.g. you have a formal difference, and a relation that says when two formal differences are equal.

\section{Truncations as HITs}
%TODO: Stefan
\newcommand{\ntrunc}[2]{||#1||_{#2}}
\newcommand{\propt}[1]{\ntrunc{#1}{-1}}
Propositional truncation will be written $\propt{A}$

HIT of $\propt{A}$:
Simple constructor
$$\propt{-} : A \rightarrow \propt{A}$$
All values are equal
$$squash : \Pi_{a, b : \propt{A}} . a =_{\propt{A}} b$$

Induction Principle:
$$z : \propt{A} \vdash P(z) : U$$
$$x : A \vdash p : P(\propt{x})$$
$$x, y : \propt{A}, u : P(x), v : P(y) \vdash q : u =_{squash(x, y)}^{z.P} v$$
gives
$$z : \propt{A} \vdash ind[z.P](p, x, y, u, v, q)(z) : P(z)$$

Set truncation as a HIT
\newcommand{\sett}[1]{\ntrunc{#1}{0}}
$$\sett{-} : A \rightarrow \sett{A}$$
$$x, y : \sett{A}, p, q : x =_{\sett{A}} y \vdash sq(x, y, p, q) : p =_{x = y} q$$

Induction principle
$$z : \sett{A} \vdash P : U$$
$$x : A \vdash p : P(\sett{A})$$
$$x, y : \sett{A}, z : P(x), w : P(y), p, q : x = y, r : z=_p^{z.P} w, s : z =_q^{z.P} w \vdash ip : p =_{sq(x,y,p,q)}^{z.P} q$$
gives
$$z : \sett{A} \vdash P(z)$$

\begin{proposition}\label{prop:sett}
If $A$ is a set, it is equivalent to its own set truncation, i.e.

\[\mathsf{isSet}(A) \to \sett{A} \simeq A\]
\end{proposition}

\section{Fundamental group of $\SS^1$}
%TODO: Maurer
Recall $\SS^1$ is a HIT defined by

$$base : \SS^1$$
$$loop : base =_{\SS^1} base$$

Recall $\Omega(A, a_0) := (a_0 =_A a_0)$

Find Gp of A at $a_0$ : $\sett{\Omega(A, a_0)}$

\begin{thm}
We want to show that
$$\pi_1(\SS^1) \simeq Z$$
\begin{proof}
Show $\Omega(\SS^1, base) \simeq Z$ (this suffices by Proposition~\ref{prop:sett}.)

$$loop^{(-)} : Z \rightarrow \Omega(\SS^1)$$
$$loop^{(0)} = \refl(base)$$
$$loop^{(-n)} = loop^{(-n + 1)} \cdot loop^{-1}$$
$$loop^{(+n)} = loop^{(n - 1)} \cdot loop$$
e.g. defined by the Z recursor

$$winding : \Omega(\SS^{1}) \rightarrow Z$$
We take that $succ : Z \simeq Z$, and $pred = succ^{-1}$, defined by shifting all the numbers up/down by one

So, we have
$$ua(succ) : Z = Z$$

By recursion principle (not induction)
$$code : \SS^1 \rightarrow U$$
$$code(base) = Z$$
$$code(loop) = ua(succ)$$

$$ap_{code} : \Omega(\SS^1) \rightarrow (Z = Z)$$
$$winding(p) = tr[x.x](\ap_{code}(p))(0)$$
%\begin{prop}
$$\Pi_{n : Z} . winding(loop^{(n)}) =_Z n$$
straightforwards by induction
%\end{prop}

%\begin{prop}
$$\Pi_{l : \Omega(\SS^1)} loop^{winding(l)} =_{\Omega(\SS^1)} l$$
Path induction on l?

Path not free

$$encode : \Pi_{x : \SS^1} (base = x) \rightarrow code(x)$$
$$decode : \Pi_{x : \SS^1} code(x) \rightarrow base = x$$

$$encode x p = tr[code](p)(o)$$
$$decode x = \SS^1-rec[z.code(z) \rightarrow base = z](\lambda z . refl(base), \lambda n . loop^{(n)})(x)$$


You weill need a path induction and circle induction
%\end{prop}
\end{proof}
\end{thm}

\end{document}
